<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>画像寄せの動き + 赤字ライン背景（オレンジ系）</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

<style>
  body{
    margin:0;
    background:#f3f4f6;
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif;
    color:#111827;
  }
  .wrapper{
    max-width:1100px;
    margin:24px auto;
    background:#fff;
    border-radius:14px;
    box-shadow:0 10px 28px rgba(0,0,0,.08);
    padding:16px 18px 18px;
  }
  h1{
    font-size:15px;
    margin:0 0 10px;
    font-weight:700;
  }
  .chartBox{
    height:320px;
    position:relative;
  }
  canvas{
    width:100% !important;
    height:100% !important;
    display:block;
  }
  .note{
    font-size:12px;
    color:#6b7280;
    margin-top:10px;
    line-height:1.45;
  }
  @media (max-width: 720px){
    .wrapper{ margin:12px; }
    .chartBox{ height:260px; }
  }
</style>
</head>
<body>
<div class="wrapper">
  <h1>ランキング / セラー数 / 価格 + 赤字ライン（画像寄せ・オレンジ系）</h1>
  <div style="display:flex;align-items:center;gap:10px;margin:8px 0 6px;">
    <label style="font-size:12px;color:#374151;">赤字ライン（USD）</label>
    <input id="lossInput" type="number" step="0.1" value="5.7"
      style="width:80px;padding:4px 6px;border:1px solid #d1d5db;border-radius:6px;font-size:12px;">
    <span style="font-size:12px;color:#6b7280;">※価格軸の損益分岐</span>
  <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:#374151;">
    <input id="lossToggle" type="checkbox" checked>
    赤字ラインを表示
  </label>

  </div>

  
  <div class="chartBox"><canvas id="chartA"></canvas></div>
  <div class="chartBox" style="margin-top:28px;"><canvas id="chartB"></canvas></div>
  <div class="chartBox" style="margin-top:28px;"><canvas id="chartC"></canvas></div>

  <div class="note">
    画像の傾向に寄せて、(1)ランキングは55k〜66k中心＋数回のスパイク、(2)セラー数は段階的なステップ、(3)価格は9〜10中心→終盤で下落、を再現しています。
  </div>
</div>

<script>
Chart.register(window['chartjs-plugin-annotation']);

const N = 180;
const labels = Array.from({length:N}, (_,i)=> `${N-i}日`);

// 乱数（再現性）
let seed = 42;
function rand(){
  seed = (seed * 1664525 + 1013904223) % 4294967296;
  return seed / 4294967296;
}
function noise(scale){ return (rand()-0.5) * scale; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// --- 価格（USD） ---
const price = [];
for(let i=0;i<N;i++){
  let v;
  if(i < 15){
    v = 12 - (i/15)*1.8;
  } else if(i < 60){
    v = 10.2 - ((i-15)/45)*0.8;
  } else if(i < 110){
    v = 9.4 - ((i-60)/50)*0.4;
  } else if(i < 140){
    v = 9.0 + ((i-110)/30)*0.4;
  } else if(i < 155){
    v = 9.4 - ((i-140)/15)*0.7;
  } else if(i < 165){
    v = 8.7 - ((i-155)/10)*2.5;
  } else {
    v = 6.2 + ((i-165)/15)*0.4;
  }

  // 最小が 6.3 未満にならないように（過去最安値を 6.3 以上にする前提）
  v = clamp(v + noise(0.14), 6.3, 12.2);

  v = Math.round(v * 10) / 10;
  price.push(v);
}

// ★要望(1)：120日目（index=60）は最安値に該当しない値にする
const idx120 = 60;
if (idx120 >= 0 && idx120 < price.length){
  // 9.0前後の帯に寄せて「最安値(6.3)」にはならない値に固定
  price[idx120] = 9.2;
}

// ★要望(2)：過去最安値が同値で複数ある場合、右側（最新側）に一番近い最安値に●を付ける
// ＝ 最小値を求めた上で、"最後に出現した" 最小値の index を採用する
let minPrice = Infinity;
for (let i=0; i<price.length; i++){
  if (price[i] < minPrice) minPrice = price[i];
}
let minIdx = -1;
for (let i=0; i<price.length; i++){
  if (price[i] === minPrice) minIdx = i; // 同値なら更新 → 最終的に一番右が残る
}

// マーカー用
const priceMinMarker = new Array(N).fill(null);
if (minIdx >= 0) priceMinMarker[minIdx] = minPrice;

// --- セラー数 ---
const sellers = [];
for(let i=0;i<N;i++){
  let v = 7;
  if(i < 25) v = 7;
  else if(i < 55) v = 7;
  else if(i < 70) v = 6;
  else if(i < 85) v = 7;
  else if(i < 95) v = 6;
  else if(i < 120) v = 8;
  else if(i < 150) v = 7;
  else if(i < 160) v = 8;
  else if(i < 172) v = 12;
  else v = 11;
  sellers.push(v);
}

// --- ランキング ---
const rank = [];
let r = 55500;
for(let i=0;i<N;i++){
  r += noise(700);

  if(i >= 30 && i < 45) r += 250;
  if(i >= 45 && i < 55) r -= 350;
  if(i >= 60 && i < 75) r += 300;
  if(i >= 75 && i < 85) r -= 280;

  if(i === 92 || i === 118) r += 6500;
  if(i === 100) r -= 4500;

  if(i > 140) r += 120;

  r = clamp(r, 49000, 67000);
  rank.push(Math.round(r));
}

// ===== 赤字ライン =====
let LOSS_LINE = 5.7;

const ORANGE = '#f59e0b';
const ORANGE_LINE = 'rgba(245,158,11,.85)';
const ORANGE_FILL = 'rgba(245,158,11,.12)';

const lossBgPlugin = {
  id:'lossBg',
  beforeDatasetsDraw(chart,args,opts){
    if(opts && opts.enabled === false) return;
    const {ctx,chartArea,scales}=chart;
    if(!chartArea) return;
    const y = scales.yPrice.getPixelForValue(opts.loss);
    ctx.save();
    ctx.fillStyle = ORANGE_FILL;
    ctx.fillRect(chartArea.left, y, chartArea.right-chartArea.left, chartArea.bottom-y);
    ctx.restore();
  }
};
Chart.register(lossBgPlugin);



function buildChart(canvasId, seedBase){
  // seed をチャートごとに変える（再現性あり）
  seed = 1000 + seedBase * 777;

  // ---- データ生成（このチャート専用）----

  // --- 価格（USD） ---
  const price = [];
  for(let i=0;i<N;i++){
    let v;
    // 3パターンで「価格の形」を変える（見え方確認用）
    if(seedBase === 1){
      // ゆるやかな下落 → 反発
      if(i < 120) v = 10.6 - i*0.015;
      else v = 8.8 + (i-120)*0.012;
    }else if(seedBase === 2){
      // 上下に振れる（レンジ）
      v = 9.2 + Math.sin(i/7)*0.85 + Math.sin(i/19)*0.35;
    }else{
      // じわ下げ + 小さめの波
      v = 11.0 - i*0.010 + Math.sin(i/12)*0.42;
    }
    v = clamp(v + noise(0.22), 5.8, 12.5);
    v = Math.round(v * 10) / 10;
    price.push(v);
  }

  // --- セラー数（価格と逆相関っぽく） ---
  // セラー数が減ると価格が上がる / 増えると価格が下がる雰囲気を「なんとなく」反映
  const sellers = [];
  const avgPrice = price.reduce((a,b)=>a+b,0) / price.length;
  const baseSeller = (seedBase===2) ? 9 : 8;   // パターンにより基準を少し変える
  const k = (seedBase===2) ? 1.6 : 1.25;       // 逆相関の強さ（雰囲気）
  for(let i=0;i<N;i++){
    // 価格が平均より高いほど sellers は減る（逆相関）
    let s = baseSeller + (avgPrice - price[i]) * k;

    // たまに急に増減する感じも少し足す（でも価格と完全同期にはしない）
    if(seedBase === 1 && (i===40 || i===95 || i===140)) s += (rand() > 0.5 ? 1 : -1) * 2;
    if(seedBase === 2 && (i%37===0)) s += (rand() > 0.5 ? 1 : -1) * 1.5;
    if(seedBase === 3 && (i===70 || i===155)) s += (rand() > 0.5 ? 1 : -1) * 1.8;

    s = clamp(Math.round(s + noise(0.55)), 4, 14);
    sellers.push(s);
  }

  // --- ランキング（雰囲気だけ：軽い逆相関を混ぜる） ---
  const rank = [];
  let r = 55500 + noise(1200);
  for(let i=0;i<N;i++){
    // sellers が少ないほど価格が高くなりがち → ランキングも少し良く（数値小さく）なりがち、程度の弱い相関
    const sellerEffect = (10 - sellers[i]) * 55;

    r += noise(650);
    r += sellerEffect;
    if(i === 92 || i === 118) r += 6500;
    if(i === 100) r -= 4500;
    if(i > 140) r += 110;

    r = clamp(r, 49000, 67000);
    rank.push(Math.round(r));
  }

  // --- 過去最安値（右側＝最新に近い最安値に●） ---
  let minPrice = Infinity;
  for (let i=0; i<price.length; i++){
    if (price[i] < minPrice) minPrice = price[i];
  }
  let minIdx = -1;
  for (let i=0; i<price.length; i++){
    if (price[i] === minPrice) minIdx = i;
  }
  const priceMinMarker = new Array(N).fill(null);
  if (minIdx >= 0) priceMinMarker[minIdx] = minPrice;

  return new Chart(document.getElementById(canvasId),{


  type:'line',
  data:{
    labels,
    datasets:[
      { label:'ランキング', data:rank, yAxisID:'yRank', borderColor:'#3b82f6', borderWidth:2, pointRadius:0, tension:.25 },
      { label:'セラー数', data:sellers, yAxisID:'ySeller', borderColor:'#fb7185', borderWidth:2, pointRadius:0, tension:0 },
      { label:'価格(USD)', data:price, yAxisID:'yPrice', borderColor:ORANGE, borderWidth:2, pointRadius:0, tension:0 },
      {
        label:'過去最安値',
        data: priceMinMarker,
        yAxisID:'yPrice',
        showLine:false,
        pointRadius:6,
        pointHoverRadius:8,
        pointBackgroundColor: ORANGE,
        pointBorderColor:'rgba(255,255,255,0.95)',
        pointBorderWidth:3
      }
    ]
  },
  options:{
    responsive:true,
    maintainAspectRatio:false,
    interaction:{mode:'index',intersect:false},
    plugins:{
      legend:{display:true},
      lossBg:{loss:LOSS_LINE},
      annotation:{
        annotations:{
          loss:{
            type:'line',
            yMin:LOSS_LINE,
            yMax:LOSS_LINE,
            yScaleID:'yPrice',
            borderColor: ORANGE_LINE,
            borderDash:[6,6],
            borderWidth:1.5,
            label:{
              display:true,
              content:'赤字ライン',
              position:'end',
              backgroundColor:'rgba(255,255,255,.92)',
              color: ORANGE,
              padding:6,
              borderRadius:8
            }
          },
          minPoint:{
            type:'point',
            xValue: minIdx,
            yValue: minPrice,
            xScaleID:'x',
            yScaleID:'yPrice',
            radius: 7,
            backgroundColor: ORANGE,
            borderColor: 'rgba(255,255,255,0.95)',
            borderWidth: 3,
            label:{
              display:true,
              content:'過去最安値',
              position:'top',
              backgroundColor:'rgba(255,255,255,.92)',
              color: ORANGE,
              padding:6,
              borderRadius:8,
              yAdjust: -6
            }
          }
        }
      }
    },
    scales:{
      x:{ticks:{maxTicksLimit:12}},
      yRank:{
        position:'left',
        title:{display:true,text:'ランキング'},
        suggestedMin:48000,
        suggestedMax:68000
      },
      ySeller:{
        position:'right',
        title:{display:true,text:'セラー数'},
        grid:{drawOnChartArea:false},
        suggestedMin:5,
        suggestedMax:12
      },
      yPrice:{
        position:'right',
        offset:true,
        title:{display:true,text:'価格(USD)'},
        grid:{drawOnChartArea:false},
        suggestedMin:4.8,
        suggestedMax:12.5
      }
    }
  }

  });
}

const chartA = buildChart('chartA',1);
const chartB = buildChart('chartB',2);
const chartC = buildChart('chartC',3);

// ===== 赤字ライン ON / OFF =====

const lossToggle = document.getElementById('lossToggle');
lossToggle.addEventListener('change', () => {
  const show = lossToggle.checked;
  chart.options.plugins.annotation.annotations.loss.display = show;
  chart.options.plugins.lossBg.enabled = show;
  chart.update();
});

// ===== 赤字ライン入力UI =====
const lossInput = document.getElementById('lossInput');
lossInput.addEventListener('input', () => {
  const v = parseFloat(lossInput.value);
  if (isNaN(v)) return;
  LOSS_LINE = v;

  chart.options.plugins.annotation.annotations.loss.yMin = v;
  chart.options.plugins.annotation.annotations.loss.yMax = v;

  chart.options.plugins.lossBg.loss = v;

  chart.update();
});
</script>
</body>
</html>
